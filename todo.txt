todo


/// to ssh
ssh joey.cs.clemson.edu
cd Documents/Curr/Ge/xv6/xv6-public

/// to exit qemu
Ctrl-A
quit

////
SYSCALL(getprocsinfo) // not direct call to SYS_getprocsinfo, since that 
// can only happen in kernal mode, instead sets up trap, see above "int $T_etc


/// Questions
Q1: why are there two verison of each sys call? eg sys_wait() and wait()
if the sys one is the "in-house, available to system code" and the other the "for users" one, then why does sys_wait() call wait() and not vice versa! (However, sys_chdir does not call chdir)
I literally called getprocsinfo, but before it gets called the other guy gets called BACKWARDS

$ ./testgetprocsinfo
usertests starting
sys_getprocsinfo called
getprocsinfo called
pid: 1, name: init
pid: 2, name: sh
pid: 3, name: testgetprocsinf

Q3
!!!!!!
we're using c to make an os, but doesn't c have a bunch of functions in a library, that assume the existence of an os. Circular? eg printf in the stdio prints to device, by calling os functions. Summary of question: how does c print stuff to terminal screen. 
I guess OS functions must not rely on those parts of C, since those parts of C rely on OS functions
e.g. their own version of prindtf (with different params, grr)
Circular
but I think that's logically circular and thus impossible because it would mean that exec is implemented by sys_exec, but if you look at the code sys_exec calls exec()

Q4
!!!!!!!
functions in user.h, where are they defined?! i can't find it eg sleep(int and open(char* 
they are just mapped directly to a system call

Q5
getprocsinfo(struct procinfo* info){
	// assumes info is already allocated by the caller
	 // where is the interrupt? Is accessing the ptable a priviledged instruction??????
	 //(?????)

//
