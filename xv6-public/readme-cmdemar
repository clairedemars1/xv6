Claire DeMars
Advanced OS
Project 2
Due 2/13/2018

Changes Made:

	Nullptr Exceptions
	- Makefile: changed entry point for all user executables 
	(-Ttext flag argument)
	- exec.c (exec function) : added guard page at bottom of user memory
	- syscall.c (argptr function) checked that the requested access 
	address was not in the nullptr guard page
	
	Shared Pages
	- syscall setup: syscall.h, syscall.c usys.S, user.h
	- 




Plan of attack:

null ptr exceptions
1. move code from page 0 to page 1, and check usertests still work
	- userinit in proc.c (I changed a 0 address)
	- Makefile: I changed 3 0s
	- initcode.S: I changed a number in exec
	- exec.c: I looked at exec function, which allocates the pages, but doesn't seem to hardcode any addresses (but couldn't find where readi was defined, or allocuvm)
2. find code that generates an error for somethign similar to dereferencing null ptr 
	- exec.c exec function, goto bad )
3. find who handles the dereferencing of memory pointers
	- walkpgdir() seems to be the function in charge of finding which page to go to, so it could check if the value it gets is 0, and throw the exception if nec
4. make #3 generate an error 

shared memory
1. 

hint
tell other guy to sleep, write, other guy wakes and reads

Notes:
how does paging do protection? what replaces base and bound? Answer: if the first part of the address doesn't match an entry
in the page table (see walkpgdir)

	
Questions
Q1
- exec.c
a. what is ph.vaddr vs ph.memsize, are they redundant?
b. exec checks if the binary requests an amount of memory (ph.vaddr)
that is a multiple of the page size, and if not, it exits, but how would the binary know what page size you use?
 I guess the compiler asks the OS when it makes the binary?
 Q2
 - base and bounds are checked by hardware (at least for user code), so why does the argptr function
 check them? the argptr function is kernal, but why wouldn't the kernal just use the existing machinery, and load it's own bounds limit
 into tohe bounds register? well, for one, b/c their is no base and bounds, it's become the page table now (which only the kernal can edit)

Q3 - git
a. tags in .gitignore file is not working, why?
b. Branch shmem set up to track remote branch shmem from origin.

Q4
the anding, 
eg #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF) in mmu.h
eg page directory index PDX in mmu.h

Q5
vm.c
  pde = &pgdir[PDX(va)];
why make a pointer here? 
what you really need to do is take off the extra bits from the pointer part of it, which requires calling some function like PDX

Q6 
// (claire is this (the address of) the entry in the page directory or of the entry in the underlying page table? )
static pte_t *
walkpgdir(pde_t *pgdir, const void *va, int alloc)
