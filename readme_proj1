Claire DeMars
Advanced OS
Project 1
Due 1/30/2018

Changes Made:
	procinfo.h: defined a struct to store proc info
	proc.c: implementation, based on procdump
	sysproc.c: "sys_" version, calling argptr
	syscall.c syscall.h: regular syscall setup
	defs.h: declared kernal version of 
	testgetprocsinfo.c: test code

Overhead:
	The new syscall, getprocsinfo, does not increase memory/space overhead
	significantly, because it uses a data structure that
	already existed (ptable), allocates a limited amount of memory
	(an array of 64 new structs) using existing methods (argptr() calls).
	and uses the same setup strategies as the previously existing system
	calls. 
	
Changes Made: **Details**
	- the user version is the real sys call (call it "foo")
	- syscall.h defines number id variables for the syscalls
	naming them with the prefix SYS_ as in SYS_foo
	- usys.S writes assembly that replaces all calls to foo in the usercode
	 with assembly code that 1. loads the syscall id then 2. generates a syscall interrupt (64)
	 - syscall.c defines what kernal function that call should go to (often called sys_foo, for trackability)
	 - sys_foo can get defined in sysfile.c or sysproc.c
	 - sys_foo calls argptr, argint, etc. to somehow get the args that were passed to foo, 
	 it then does it's implementation, which can include calling a kernal version of foo, that is not the same as the user foo
	 i think foo is declared in defs.h (which both kernal and user code can get to)

	usys.S
	#define SYSCALL(name) \
	  .globl name; \
	  name: \
		movl $SYS_ ## name, %eax; \
		int $T_SYSCALL; \
		ret
	SYSCALL(getprocsinfo) 
	\\ E.G. if names is foo $SYS_ ## name becomes SYS_foo
	\\ every* call to foo gets turned into a load of SYS_foo into the register %eax, 
	\\ then a "hey, we have a syscall" interrupt
	\\ then a return back to normal
	\\ that means that every call to foo() generates an interrupt, with %eax
	\\ storing info on which syscall to use (the number defined for that syscall in syscall.h
	* not every all to foo, just the ones in user code (as op. to kernal code)
	  we know b/c 

	
	cprintf is kernal function
	
	// should allocate the memory, how know how much? 
	// how know what code is userside, and what is kernal side
	// know defs.h is user b/c it has standard library (kernal can't use stl b/c they are just wrappers on system calls)
	// params.h is both b/c grep for #include "params.h" and it shows up in fs. and 
	// why user version of function same name as in-kernal, since you can't use system call inside kernal, cuz 

